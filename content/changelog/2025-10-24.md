---
title: Console updates and improvements
---

### Claude Code plugin for Neon

We've launched the **Neon Claude Code plugin**, a comprehensive integration that brings Neon's capabilities directly into Claude Code, Anthropic's AI development environment.

The plugin includes:

- **4 Claude Skills** for guided workflows:
  - **neon-drizzle**: Set up Drizzle ORM with Neon, including schema creation and connection setup
  - **neon-serverless**: Configure Neon's serverless Postgres driver and test connections
  - **neon-toolkit**: Use the Neon Management API to create databases, projects, and branches dynamically
  - **add-neon-knowledge**: Access Neon documentation snippets and usage examples

- **MCP server integration** that lets Claude interact with Neon's live API endpoints to:
  - Query Neon for project information
  - Create or delete branches and databases
  - Validate connection strings
  - Run SQL queries and migrations

- **Portable context rules (.mdc files)** that can be used in other AI tools like Cursor

Install it from the Neon marketplace:

```bash
/plugin marketplace add neondatabase-labs/ai-rules
/plugin install neon-plugin@neon
```

For more information, see [Claude Code plugin for Neon](/docs/ai/ai-claude-code-plugin).

## Branch navigation improvements

We've added breadcrumb navigation to branch pages, making it easier to understand and navigate your branch hierarchy. When viewing a child branch, you'll now see the full lineage path (e.g., `production / development / feature-branch`) with visual branch indicators. The page heading has also been updated to "Child branch overview" for better clarity when working with nested branches.

![Branch breadcrumb navigation](/docs/changelog/branch-breadcrumbs-oct-2025.png)

<details>
<summary>**Fixes & improvements**</summary>

- **Child branch storage now capped at logical data size**

  We've introduced a storage billing cap for child branches. Previously, child branches storage cost was based on all data changes over time. Now, you're billed for the minimum of accumulated changes or your actual data size, ensuring you never pay more than the logical size of your data on the child branch. This change makes child branch storage costs more predictable and helps avoid charges from long-lived branches.

</details>
